//
// Created by Nebulous on 2022/5/9.
//

#include "codeGeneration.h"
using namespace std;
extern _SymTable *mainSymbolTable;
extern _SymTable *nowSymbolTable;//当前符号表
extern _SymRecord *searchsymbolRecord(_SymTable* symbolTablePtr, string id, int mode = 0);
extern bool checkIsReferredPara(_SymTable *nowSymbolTable, string id);
extern string integer2string(int num);
void Generator::run(){
    this->currentSymbolTabPtr = mainSymbolTable;
    f_out.open(file_name, ios_base::out);

    //------------- get info -------------
    getSubProDecList();
    getConstList(ASTRoot->programBody->constList, this->global_constIds, this->global_constTypes,
                 this->global_constVals, this->currentSymbolTabPtr);
    getVarList(ASTRoot->programBody->variantList, this->global_varIds, this->global_varTypes,
               this->main_arraySizes, this->currentSymbolTabPtr);
    getSubProDefList(ASTRoot->programBody->FunctionProcedureList);
    getSubMainFunction();

    //--------------- output --------------
    f_out<<"// Generated by pascal-to-c program, program name "<<ASTRoot->programId.first<<endl;
    f_out<<"//--------------------headers--------------------"<<endl;
    outputHeaders();
    f_out<<"//------------global const definition------------"<<endl;
    outputConsts(global_constIds, global_constTypes, global_constVals, 0);
    f_out<<"//----------global variables definition----------"<<endl;
    outputVars(global_varIds, global_varTypes, main_arraySizes, 0);
    f_out<<"\n//------------ProgramBody declaration-------------"<<endl;
    outputSubProDeclareList();
    f_out<<"\n//---------------------main----------------------"<<endl;
    outputMain(ASTRoot->programId.first);
    f_out<<"\n//------------ProgramBody definition--------------"<<endl;
    outputSubProDefList();

    f_out.close();
}
//================================tools============================
void Generator::mapHeaders(const string& func_name) {
    if(this->func2header.count(func_name)&&
       find(headers.begin(), headers.end(), this->func2header[func_name])==headers.end())
        this->headers.push_back(this->func2header[func_name]);
}
string Generator::pascalType2cType(const string& pascalType){
    if (pascalType == "integer")    return "int";
    if (pascalType == "real")       return "float";
    if (pascalType == "boolean")    return "bool";
    if (pascalType == "char")       return "char";
    if (pascalType.empty())           return "";
    cout << "[transformType] pascalType error" << endl;
    return "";
}
string Generator::pascalOp2cOp(string op){
    if(op=="not")   return "!";
    if(op=="=")     return "==";
    if(op=="<>")    return "!=";
    if(op=="or")    return "||";
    if(op=="div")   return "/";
    if(op=="mod")   return "%";
    if(op=="and")   return "&&";
    if(op=="minus") return "-";
    return op;
}
string Generator::pascalType2outputFormat(const string& type) {
    if (type == "integer")
        return "%d";
    if (type == "real")
        return "%f";
    if (type == "char")
        return "%c";
    if (type == "boolean")
        return "bool";
    if (type == "")
        return "";
    cout << "[getOutputFormat] retType error" << endl;
    return "";
}
int Generator::isEqual(int num,...){
    va_list argp;
    int para;
    va_start(argp, num);
    int pre=va_arg(argp, int);
    for(int argno=1; argno<num; ++argno){
        para = va_arg(argp, int);
        if(para!=pre)
            return false;
    }
    va_end(argp);
    return true;
}
//运算符优先级，级别越大，优先级越低，最大应设为8
int Generator::biOpLevel(const string& cOperand){
    set<string> assign={"=", "+=", "-=", "*=", "/=", "%=", "&=", "^=", "|=", "<<=", ">>="};
    set<string> bi_relop={"||", "&&"};
    set<string> bit={"^", "&", "|"};
    set<string> equal_judge = {"==", "!="};
    set<string> cmp_judge = {">=", "<=", "<", ">"};
    set<string> shift = {"<<=", ">>=", "<<", ">>"};
    set<string> bi_add_minus = {"+", "-"};
    set<string> bi_mul_div = {"*", "/", "%"};
    if(assign.find(cOperand)!=assign.end())     return 8;
    if(bi_relop.find(cOperand)!=bi_relop.end()) return 7;
    if(bit.find(cOperand)!=bit.end())           return 6;
    if(equal_judge.find(cOperand)!=equal_judge.end())   return 5;
    if(cmp_judge.find(cOperand)!=cmp_judge.end())   return 4;
    if(shift.find(cOperand)!=shift.end())       return 3;
    if(bi_add_minus.find(cOperand)!=bi_add_minus.end()) return 2;
    if(bi_mul_div.find(cOperand)!=bi_mul_div.end())     return 1;
    else{
        cerr<<"[biOpLevel] Not binary operand"<<endl;
        return -1;
    }
}

bool Generator::LibraryFunctionCall(_Call* procedureCall,
                                    vector< pair<string, int> > &sentences, int retract){
    string &id = procedureCall->ID.first;
    string statement;

    if (id == "write"){
        statementOfWrite(procedureCall->argumentList, sentences, retract);
    }else if(id =="read"){
        string in,params;
        for(auto & i : procedureCall->argumentList){
            string expression = getExpression(i);
            string typeFormat = pascalType2outputFormat(i->expressionType);
            if(typeFormat == "bool")
                typeFormat = "%d";
            in += typeFormat;
            params += ", &" + expression;
        }
        statement = "scanf(\"" + in + "\"" + params + ");";
        sentences.emplace_back(statement,retract);
    }else return false;

    return true;
}

void Generator::statementOfWrite(vector<_Expression *> actualParams,
                                   vector< pair<string, int> > &sentences, int retract){
    string statement,out,params;
    for(auto & actualParam : actualParams){
        string expression = getExpression(actualParam);
        string typeFormat = pascalType2outputFormat(actualParam->expressionType);
        //发现布尔值，截止
        if(typeFormat == "bool"){
            if(!out.empty()){
                statement += "printf(\"" + out + "\"" + params + ");";
                sentences.emplace_back(statement,retract);
                statement="",out="",params="";
            }
            statementOfBool(expression,sentences,retract);
        }else{
            if(typeFormat.empty()&&actualParam->type=="compound")
                typeFormat = pascalType2outputFormat(actualParam->operand1->expressionType);
            out += typeFormat;
            params += ", " + expression;
        }
    }

    if(!out.empty()){
        statement += "printf(\"" + out + "\"" + params + ");";
        sentences.emplace_back(statement,retract);
    }
}

void Generator::statementOfBool(const string& expression,vector< pair<string, int> > &sentences, int retract){
    sentences.emplace_back("{", retract);
    sentences.emplace_back("if(" + expression + ")", retract + 1);
    sentences.emplace_back("printf(\"true\");", retract + 2);
    sentences.emplace_back("else", retract + 1);
    sentences.emplace_back("printf(\"false\");", retract + 2);
    sentences.emplace_back("}", retract);
}

//==========================get Pascal info=============================
void Generator::getSubProDecList() {
    subProDeclare declaration;
    for(auto& record:mainSymbolTable->symbolList){
        if((record->flag=="procedure" || record->flag=="function")
           && record->subSymbolTable){
            declaration.clear();
            declaration.returnType = pascalType2cType(record->type);
            declaration.id = record->id;
            _SymTable *subTable = record->subSymbolTable;
            for (int i = 1; i <= record->amount; ++i) {
                declaration.paramIdList.push_back(subTable->symbolList[i]->id);
                declaration.paramIsRefList.push_back(checkIsReferredPara(subTable, declaration.id));
                declaration.paramTypeList.push_back(pascalType2cType(subTable->symbolList[i]->type));
            }
            subProDecList.push_back(declaration);
        }
    }
}
void Generator::getConstList(vector<_Const *> &constList, vector<string> &constIds, vector<string> &constTypes,
                             vector<string> &constVals, _SymTable *symbolTablePtr) {
    constIds.clear();
    constTypes.clear();
    constVals.clear();
    for(auto &constItem:constList){
        if(!constItem){
            cerr<<"[getConstList] Null pointer in constList."<<endl;
            return;
        }
        constIds.push_back(constItem->ID.first);
        auto record = searchsymbolRecord(symbolTablePtr, constItem->ID.first, 1);
        string constVal;
        if(record->type!="char"&&record->isNegative)
            constVal+="-";
        constVal += record->value;
        constTypes.push_back(pascalType2cType(record->type));
        constVals.push_back(constVal);
    }
}
void Generator::getVarList(vector<_Var *> &varList, vector<string> &varIds, vector<string> &varTypes,
                           vector<vector<int>> &arraySizes, _SymTable *symbolTablePtr) {
    varIds.clear();
    varTypes.clear();
    arraySizes.clear();
    for(auto &varItem:varList){
        if(!varItem){
            cerr<<"[getVarList] Null pointer in constList."<<endl;
            return;
        }
        varIds.push_back(varItem->ID.first);

        auto record = searchsymbolRecord(symbolTablePtr, varItem->ID.first, 1);
        varTypes.push_back(pascalType2cType(record->type));

        auto &pascalRanges = record->arrayRangeList;
        vector<int> cRange;
        for(auto &p_range:pascalRanges)
            cRange.push_back(p_range.second-p_range.first+1);
        arraySizes.push_back(cRange);
    }
}

void Generator::getStatementList(_Statement *statementNode, vector<pair<string, int>> &sentences,int retract, int flag){
    map<string, int>Type_Param = {
            { "compound", 1 },
            { "repeat", 2 },
            { "while", 3 },
            { "for", 4 },
            { "if", 5 },
            { "assign", 6 },
            { "procedure", 7 }};
    if(!statementNode){
        cerr<<"[getStatementList] statementNode is nullptr."<<endl;
        return;
    }
    int case_value = Type_Param[statementNode->type];
    switch (case_value) {
        case 1:{
            auto* compoundItem = reinterpret_cast<_Compound*>(statementNode);
            if(flag == 0)
                sentences.emplace_back("{",retract - 1);
            for(auto statementItem:compoundItem->statementList)
                getStatementList(statementItem,sentences,retract);
            if(flag == 0)
                sentences.emplace_back("}",retract - 1);
            break;
        }
        case 2:{
            auto* repeatItem = reinterpret_cast<_Repeat*>(statementNode);

            string condition = "while(!("
                                + getExpression(repeatItem->condition)
                                + "));";
            sentences.emplace_back("do",retract);
            getStatementList(repeatItem->_do,sentences,retract + 1);
            sentences.emplace_back(condition,retract);
            break;
        }
        case 3:{
            auto* whileItem = reinterpret_cast<_While*>(statementNode);

            string condition = "while("
                               + getExpression(whileItem->condition)
                               + ")";
            sentences.emplace_back(condition,retract);
            getStatementList(whileItem->body, sentences, retract + 1);
            break;
        }
        case 4:{
            auto* forItem = reinterpret_cast<_For*>(statementNode);

            string var = forItem->id.first;
            string start = getExpression(forItem->start);
            string end = getExpression(forItem->end);
            sentences.emplace_back("for(" + var + " = " + start + ";"
                                                    + var + " <= " + end + ";"
                                                    + var + "++)",retract);
            getStatementList(forItem->body, sentences, retract + 1);
            break;
        }
        case 5:{
            auto* ifItem = reinterpret_cast<_If*>(statementNode);

            string condition = getExpression(ifItem->condition);
            sentences.emplace_back("if(" + condition + ")",retract);
            getStatementList(ifItem->then,sentences,retract + 1);

            //判断有无else
            if(ifItem->els != nullptr){
                sentences.emplace_back("else",retract);
                getStatementList(ifItem->els,sentences,retract+1);
            }
            break;
        }
        case 6:{
            auto* assignItem = reinterpret_cast<_Assign*>(statementNode);

            string expression = getExpression(assignItem->expression);
            string varLeft;
            if(assignItem->variantReference->kind == "function return")
                varLeft = "return (" + expression + ");";
            else
                varLeft = getVariant(assignItem->variantReference) + " = " + expression + ";";

            sentences.emplace_back(varLeft,retract);
            break;
        }
        case 7:{
            auto* ProcCallItem = reinterpret_cast<_Call*>(statementNode);
            //获取C语言库函数
            string ProcCallstr = ProcCallItem->ID.first;
            mapHeaders(ProcCallstr);

            auto record = searchsymbolRecord(mainSymbolTable, ProcCallstr);
            if (record == nullptr || record->flag != "procedure") {
                cout << "[getStatementList] procedure not found" << endl;
                return;
            }

            //是否是库函数，若是，则在该函数内完成语句添加
            if (LibraryFunctionCall(ProcCallItem,sentences,retract))
                return;
            //构造语句
            ProcCallstr += "(";
            for(int i=0;i<ProcCallItem->argumentList.size(); ++i){
                if(i)   ProcCallstr += ", ";
                FormalParaInfo info = record->getFormalParaInfo(i);
                ProcCallstr += getExpression(ProcCallItem->argumentList[i], 9, info.second);
            }
            ProcCallstr += ");";

            sentences.emplace_back(ProcCallstr,retract);
            break;
        }
        default:
            cerr<<"[getStatementList] Illegal statement."<<endl;
            break;
    }
}

string Generator::getExpression(_Expression *expression, int parentLevel, bool isReferred) {
    if(!expression){
        cerr<<"[getExpression] expression is nullptr."<<endl;
        return "";
    }
    string ret;
    int level;
    if(expression->type=="compound"){
        //复合表达式
        if(!expression->isSingle){
            auto op = pascalOp2cOp(expression->op);
            level = biOpLevel(op);
            if(level>=parentLevel)  ret+="(";
            ret+= getExpression(expression->operand1, level) + " " +
                  pascalOp2cOp(expression->op) + " " + getExpression(expression->operand2, level);
            if(level>=parentLevel)  ret+=")";
            return ret;
        }
        else{
            if(expression->op == "bracket")
                return "("+ getExpression(expression->operand1)+")";
            if(expression->op == "minus" || expression->op == "not") {
                level = 0;
                ret += " " + pascalOp2cOp(expression->op) + getExpression(expression->operand1, level);
                return ret;
            }
        }
    }
    if(expression->type=="var"){
        return getVariant(expression->variantReference, isReferred);
    }
    if(expression->type=="integer"||expression->type=="real")
        return expression-> info;
    if(expression->type=="char")
        return "'"+expression-> info + "'";
    if(expression->type=="function"){
        getFunctionCall(expression->functionCall,ret);
        return ret;
    }
    cerr<<"[getExpression] expression retType error."<<endl;
    return "";
}
void Generator::getFunctionCall(_FunctionCall *funcCall, string &funcCallStr) {
    if(!funcCall){
        cerr<<"[getFunctionCall] funcCall is nullptr."<<endl;
        return;
    }
    funcCallStr = funcCall->ID.first;
    mapHeaders(funcCallStr);
    auto record = searchsymbolRecord(mainSymbolTable, funcCallStr);
    funcCallStr+="(";
    for(int i=0;i<funcCall->argumentList.size(); ++i){
        if(i)   funcCallStr += ", ";
        FormalParaInfo info = record->getFormalParaInfo(i);
        funcCallStr +=getExpression(funcCall->argumentList[i], 9, info.second);
    }
    funcCallStr += ")";
}
string Generator::getVariant(_Reference *variant, bool isReferredActual) {
    if(!variant){
        cerr<<"[getVariant] variant is nullptr."<<endl;
        return "";
    }
    string ret;
    ret = variant->ID.first;
    if(variant->kind=="var"||variant->kind=="array"){
        if(checkIsReferredPara(nowSymbolTable, ret)){
            if(!isReferredActual)   ret = "*"+ret;
        }
        else if(isReferredActual)   ret = "&"+ret;
    }
    if(variant->kind=="function")   ret += "()";
    //不是数组，结束
    if(variant->kind!="array")      return ret;
    //是数组
    //查符号表，查定义时的数组下界
    auto record = searchsymbolRecord(nowSymbolTable, variant->ID.first);
    for(int i=0;i < variant->dimList.size(); ++i){
        auto expression = getExpression(variant->dimList[i]);
        int lowerBound = record->arrayRangeList[i].first;
        ret += "[" + expression;
        if(lowerBound>0)
            ret += " - " + integer2string(lowerBound);
        else if(lowerBound<0)
            ret += " + " + integer2string(abs(lowerBound));
        ret += "]";
    }
    return ret;
}

void Generator::getSubProDefList(const vector<_Function *>& subProList){
    //对每个子程序
    subProDefList.clear();
    for(auto subProNode:subProList){
        if(!subProNode){
            cerr<<"[getsubproDefList] NO pointer in subProList"<<endl;
            return;
        }

        auto record = searchsymbolRecord(mainSymbolTable, subProNode->ID.first);
        //创建子程序定义结构，为其填充常量、变量及语句
        subProDef subPro;
        currentSymbolTabPtr = record->subSymbolTable;
        getConstList(subProNode->constList, subPro.constIdList,
                     subPro.constTypeList, subPro.constValueList,
                     record->subSymbolTable);
        getVarList(subProNode->variantList, subPro.varIdList, subPro.varTypeList,
                   subPro.arraySizes, record->subSymbolTable);
        getStatementList(subProNode->compound, subPro.sentences,1,1);
        subProDefList.push_back(subPro);
    }
}

void Generator::getSubMainFunction(){
    if (ASTRoot == nullptr) {
        cout << "[getSubMainFunction] pointer of _Program is null" << endl;
        return;
    }
    getStatementList(ASTRoot->programBody->compound, main_sentences, 1, 1);
}

//==============================output================================
void Generator::outputHeaders() {
    mapHeaders("boolean");
    for(auto& h:this->headers){
        f_out<<"#include <"<<h<<">"<<endl;
    }
}
void Generator::outputConsts(vector<string> &constIds, vector<string> &constTypes, vector<string> &constVals,
                             int tabs) {
    if(!isEqual(3, constIds.size(), constTypes.size(), constVals.size())) {
        cout << "[outputConstList] ERROR: constant list size miss match" << endl;
        return;
    }
    int sz = int(constIds.size());
    for(int i=0;i<sz;++i){
        for(int j=0;j<tabs;++j)
            f_out<<"\t";
        f_out<<"const "<<constTypes[i]<<" "<<constIds[i]<<" = "<<
            constVals[i]<<";"<<endl;
    }
}
void Generator::outputVars(vector<string> &varIds, vector<string> &varTypes, vector<vector<int>> &arraySizes,
                           int tabs) {
    if(!isEqual(3, varIds.size(), varTypes.size(), arraySizes.size())){
        cout << "[outputConstList] ERROR: constant list size miss match" << endl;
        return;
    }
    int sz = int(varIds.size());
    for(int i=0;i<sz;++i){
        for(int j=0;j<tabs;++j)
            f_out<<"\t";
        f_out<< varTypes[i]<<" "<<varIds[i];
        int dim = int(arraySizes[i].size());
        for(int j=0;j<dim;++j)
            f_out<<"["<<arraySizes[i][j]<<"]";
        f_out<<";"<<endl;
    }
}
void Generator::outputMain(const string& programName) {
    f_out<<"int main()\n"<<"{\n";
    f_out<<"\t"<<programName<<"();"<<endl;
    f_out<<"\treturn 0;\n}\n";
}
void Generator::outputSubProDeclareHead(subProDeclare &declare) {
    string str = declare.returnType.empty()? "void" : declare.returnType;
    f_out<<str<<" "<<declare.id<<"(";
    for(int i=0;i<declare.paramIdList.size();++i){
        if(i)   f_out<<", ";
        f_out<<declare.paramTypeList[i]<<" ";
        if(declare.paramIsRefList[i])   f_out<<"&";
        f_out<<declare.paramIdList[i];
    }
    f_out<<")";
}
void Generator::outputSubProDeclareList() {
    f_out<<mainFuncDeclare<<";"<<endl;
    for(auto &declare:subProDecList){
        outputSubProDeclareHead(declare);
        f_out<<";"<<endl;
    }
}

void Generator::outputStatementList(vector< pair<string, int> > &sentences){
    for(auto &statement:sentences){
        int n = statement.second;
        for(int i = 0;i < n;i++)
            f_out << "\t";
        f_out<<statement.first << endl;
    }
}

void Generator::outputSubProDefList(){
    //主函数
    f_out << mainFuncDeclare << endl;
    f_out << "{" << endl;
    outputStatementList(main_sentences);
    //f_out<<endl;
    f_out << "}" << endl << endl;

    int n = int(subProDefList.size());
    for(int i = 0;i<n;i++){
        outputSubProDeclareHead(subProDecList[i]);

        subProDef &item = subProDefList[i];
        f_out << "{" << endl;
        outputConsts(item.constIdList,item.constTypeList,item.constValueList ,1);
        outputVars(item.varIdList,item.varTypeList,item.arraySizes,1);
        outputStatementList(item.sentences);
        //f_out << endl;
        f_out << "}" << endl << endl;
    }
}
